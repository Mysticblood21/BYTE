<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYTE - Chat Assistant</title>
    <link rel="stylesheet" href="chatbot-styles.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Inline base reset retained for safety; main styles moved to chatbot-styles.css */

        /* Main Chatbot Page Layout */
        .chatbot-page {
            width: 100vw;
            height: 100vh;
            background: #d8d8d8;
            border: 4px solid #ffffff;
            box-sizing: border-box;
            display: flex;
            position: relative;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: #c8c8c8;
            border-right: 2px solid #888;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            z-index: 200;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 2px solid #888;
            background: #b8b8b8;
        }

        .sidebar-header h3 {
            font-size: 1.2rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
        }

        .new-chat-btn {
            width: 100%;
            padding: 12px 16px;
            background: #888;
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .new-chat-btn:hover {
            background: #777;
            transform: translateY(-1px);
        }

        /* Chat List */
        .chat-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .no-chats {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            line-height: 1.4;
        }

        .chat-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            margin-bottom: 8px;
            background: #b8b8b8;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-item:hover {
            background: #a8a8a8;
            border-color: #999;
        }

        .chat-item.active {
            background: #a8a8a8;
            border-color: #777;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .chat-item-content {
            flex: 1;
            min-width: 0;
        }

        .chat-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chat-preview {
            font-size: 0.8rem;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .chat-date {
            font-size: 0.8rem;
            color: #666;
        }

        .chat-item-actions {
            margin-left: 8px;
            display: flex;
            gap: 5px;
        }

        .chat-action-btn {
            background: none;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            color: #666;
            transition: all 0.2s ease;
        }

        .chat-action-btn:hover {
            background: #999;
            color: #fff;
        }

        /* Sidebar Footer */
        .sidebar-footer {
            padding: 15px;
            border-top: 2px solid #888;
            background: #b8b8b8;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 8px;
            background: #c8c8c8;
            border-radius: 8px;
        }

        .user-avatar-small {
            width: 35px;
            height: 35px;
            background: #888;
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 1rem;
        }

        .user-details {
            flex: 1;
            min-width: 0;
        }

        .user-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .user-email {
            font-size: 0.8rem;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .logout-btn {
            width: 100%;
            padding: 10px;
            background: #ff4757;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: #ff3742;
        }

        /* Main Chat Area */
        .main-chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        /* Header - Updated to remove delete button */
        .chat-header {
            background: #b8b8b8;
            border-bottom: 2px solid #888;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 100;
        }

        .sidebar-toggle {
            width: 40px;
            height: 40px;
            background: #a8a8a8;
            border: 2px solid #888;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            color: #333;
        }

        .sidebar-toggle:hover {
            background: #999;
            transform: scale(1.1);
        }

        .header-content {
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }

        .chat-logo {
            font-size: 2rem;
            font-weight: 900;
            color: #000;
            letter-spacing: 2px;
            margin-bottom: 2px;
        }

        .chat-subtitle {
            font-size: 0.9rem;
            color: #333;
            opacity: 0.8;
        }

        .chat-actions {
            display: flex;
            gap: 10px;
        }

        .action-header-btn {
            width: 40px;
            height: 40px;
            background: #a8a8a8;
            border: 2px solid #888;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .action-header-btn:hover {
            background: #999;
            transform: scale(1.1);
        }

        /* Chat Container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Welcome Section */
        .welcome-section {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100%;
            text-align: center;
        }

        .welcome-content h2 {
            font-size: 2.5rem;
            font-weight: 900;
            color: #000;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }

        .welcome-content p {
            font-size: 1.1rem;
            color: #333;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        /* Chat Messages */
        .chat-messages {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding-bottom: 20px;
        }

        .message {
            display: flex;
            gap: 10px;
            max-width: 80%;
            animation: messageSlide 0.3s ease-out;
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message.bot {
            align-self: flex-start;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            flex-shrink: 0;
            border: 2px solid #888;
        }

        .message.user .message-avatar {
            background: #a8a8a8;
        }

        .message.bot .message-avatar {
            background: #888;
            color: #fff;
        }

        .message-content {
            background: #c8c8c8;
            border: 2px solid #aaa;
            border-radius: 18px;
            padding: 12px 16px;
            position: relative;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .message.user .message-content {
            background: #b8b8b8;
            border-color: #999;
        }

        .message-content.image-message {
            padding: 8px;
            background: transparent;
            border: none;
        }

        .chat-image {
            max-width: 300px;
            max-height: 300px;
            width: auto;
            height: auto;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 2px solid #aaa;
        }

        .chat-image:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .message.user .chat-image {
            border-color: #999;
        }

        .message-time {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
            text-align: right;
        }

        .message.bot .message-time {
            text-align: left;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0;
            color: #666;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #888;
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typingBounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Input Area */
        .input-area {
            background: #c8c8c8;
            border-top: 2px solid #888;
            padding: 15px 20px;
        }

        .file-upload-area {
            background: #b8b8b8;
            border: 2px solid #888;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideDown 0.3s ease;
        }

        .file-preview {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #333;
            font-size: 0.9rem;
            flex: 1;
        }

        #filePreviewImage {
            max-width: 60px;
            max-height: 60px;
            border-radius: 6px;
            border: 1px solid #999;
            object-fit: cover;
        }

        .remove-file-btn {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .remove-file-btn:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        .input-container {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .input-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            background: #a8a8a8;
            border: 2px solid #888;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            background: #999;
            transform: scale(1.1);
        }

        .action-btn.active {
            background: #888;
            color: #fff;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }

        #messageInput {
            flex: 1;
            background: #d8d8d8;
            border: 2px solid #aaa;
            border-radius: 20px;
            padding: 12px 16px;
            font-size: 1rem;
            color: #333;
            resize: none;
            outline: none;
            transition: all 0.3s ease;
            min-height: 40px;
            max-height: 120px;
            line-height: 1.4;
            font-family: inherit;
        }

        #messageInput:focus {
            border-color: #888;
            background: #e0e0e0;
        }

        #messageInput::placeholder {
            color: #666;
            opacity: 0.8;
        }

        .send-btn {
            width: 40px;
            height: 40px;
            background: #888;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .send-btn:hover {
            background: #777;
            transform: scale(1.1);
        }

        .send-btn:active {
            transform: scale(0.95);
        }

        .send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* Voice Input */
        .voice-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background: #b8b8b8;
            border: 2px solid #888;
            border-radius: 12px;
            margin-bottom: 10px;
            color: #333;
            animation: slideDown 0.3s ease;
        }

        .voice-wave {
            width: 20px;
            height: 20px;
            background: #ff4757;
            border-radius: 50%;
            animation: voicePulse 1s infinite;
        }

        @keyframes voicePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Drawing Modal - Updated */
        .drawing-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .drawing-modal.active {
            opacity: 1;
            visibility: visible;
        }

.drawing-container {
        /* ... existing styles ... */
        max-width: 95vw; /* Slightly more room */
        max-height: 95vh; /* Slightly more room */
        width: auto; /* Allow it to shrink/grow based on content */
        overflow: auto; /* Add scroll if content overflows */
}

        .drawing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .drawing-header h3 {
            font-size: 1.5rem;
            color: #333;
            font-weight: 700;
        }

        .close-drawing {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-drawing:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        #drawingCanvas {
            background: white;
            border: 3px solid #888;
            border-radius: 8px;
            cursor: crosshair;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: block;
        }

        /* Updated Drawing Controls - Simplified */
        .drawing-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .drawing-controls button {
            padding: 10px 16px;
            background: #a8a8a8;
            color: #333;
            border: 2px solid #888;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .drawing-controls button:hover {
            background: #999;
            color: #fff;
        }

        .drawing-controls button.active {
            background: #888;
            color: #fff;
        }

        #brushSize {
            width: 120px;
            height: 6px;
            background: #bbb;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        #brushSize::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #888;
            border-radius: 50%;
            cursor: pointer;
        }

        .submit-drawing {
            background: #888;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .submit-drawing:hover {
            background: #777;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        /* Delete Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: #d8d8d8;
            border: 3px solid #888;
            border-radius: 15px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-content h3 {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 15px;
            font-weight: 700;
        }

        .modal-content p {
            font-size: 1rem;
            color: #666;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 24px;
            border: 2px solid #888;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .modal-btn.cancel {
            background: #c8c8c8;
            color: #333;
        }

        .modal-btn.cancel:hover {
            background: #b8b8b8;
        }

        .modal-btn.confirm {
            background: #ff4757;
            color: white;
        }

        .modal-btn.confirm:hover {
            background: #ff3742;
        }

        /* Responsive Design */
        @media (max-width: 968px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 300;
                transform: translateX(-100%);
            }
            
            .sidebar:not(.collapsed) {
                transform: translateX(0);
            }
            
            .main-chat-area {
                width: 100%;
            }
            
            .chat-image {
                max-width: 250px;
                max-height: 250px;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
            }
            
            .chat-header {
                padding: 10px 15px;
            }
            
            .chat-logo {
                font-size: 1.5rem;
            }
            
            .welcome-content h2 {
                font-size: 2rem;
            }
            
            .message {
                max-width: 95%;
            }
            
            .chat-image {
                max-width: 200px;
                max-height: 200px;
            }
            
            .input-area {
                padding: 10px 15px;
            }
            
            .input-actions {
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .action-btn {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
            
            #drawingCanvas {
                width: 100%;
                height: 300px;
            }
            
            .drawing-controls {
                justify-content: center;
            }
            
            .drawing-container {
                max-width: 95vw;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                width: 100%;
            }
            
            .sidebar-toggle, .action-header-btn {
                width: 35px;
                height: 35px;
            }
            
            .chat-logo {
                font-size: 1.3rem;
            }
            
            .welcome-content h2 {
                font-size: 1.8rem;
            }
            
            .welcome-content p {
                font-size: 1rem;
            }
            
            .new-chat-btn {
                padding: 10px 12px;
                font-size: 0.9rem;
            }
            
            .chat-image {
                max-width: 150px;
                max-height: 150px;
            }
            
            .file-preview {
                gap: 8px;
            }
            
            #filePreviewImage {
                max-width: 40px;
                max-height: 40px;
            }
            
            .drawing-controls {
                gap: 10px;
            }
            
            #brushSize {
                width: 80px;
            }
        }

        /* Custom scrollbar */
        .chat-messages::-webkit-scrollbar,
        .chat-list::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #c8c8c8;
            border-radius: 3px;
        }

        .chat-list::-webkit-scrollbar-track {
            background: #b8b8b8;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .chat-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .chat-list::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <!-- Chatbot Page -->
    <div class="chatbot-page">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h3>Chat History</h3>
                <button class="new-chat-btn" onclick="createNewChat()" title="Start New Chat">
                    New Chat
                </button>
            </div>
            
            <div class="chat-list" id="chatList">
                <!-- Chat items will be dynamically added here -->
            </div>
            
            <div class="sidebar-footer">
                <div class="user-info">
                    <div class="user-avatar-small">
                        <span id="userInitial">U</span>
                    </div>
                    <div class="user-details">
                        <div class="user-name" id="userName">Loading...</div>
                        <div class="user-email" id="userEmail">Loading...</div>
                    </div>
                </div>
                <button class="logout-btn" onclick="logout()">
                    🚪 Logout
                </button>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-chat-area">
            <!-- Header - Updated to only have clear chat button -->
            <div class="chat-header">
                <button class="sidebar-toggle" onclick="toggleSidebar()" id="sidebarToggle">
                    ☰
                </button>
                <div class="header-content">
                    <h1 class="chat-logo">BYTE</h1>
                    <p class="chat-subtitle">Smart Learning Assistant</p>
                </div>
                <div class="chat-actions">
                    <button class="action-header-btn" id="btnClearChat" onclick="clearCurrentChat()" title="Clear Chat">🗑️</button>
                    <a class="action-header-btn" id="btnClock" href="/clock.html" title="Clock" style="text-decoration:none; display:flex; align-items:center; justify-content:center;">🕒</a>
                    <a class="action-header-btn" id="btnCalculator" href="/calculator.html" title="Calculator" style="text-decoration:none; display:flex; align-items:center; justify-content:center;">🧮</a>
                    <a class="action-header-btn" id="btnTodo" href="/todo.html" title="To-Do List" style="text-decoration:none; display:flex; align-items:center; justify-content:center;">📝</a>
                </div>
            </div>

            <!-- Chat Container -->
            <div class="chat-container">
                <!-- Welcome Message -->
                <div class="welcome-section" id="welcomeSection">
                    <div class="welcome-content">
                        <h2>Welcome to BYTE!</h2>
                        <p>Your smart learning assistant is ready to help. Ask me anything!</p>
                    </div>
                </div>

                <!-- Chat Messages -->
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages will be dynamically added here -->
                </div>

                <!-- Typing Indicator -->
                <div class="typing-indicator" id="typingIndicator" style="display: none;">
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                    <span class="typing-text">BYTE is typing...</span>
                </div>
            </div>

            <!-- Input Area -->
            <div class="input-area">
                <!-- File Upload Area -->
                <div class="file-upload-area" id="fileUploadArea" style="display: none;">
                    <div class="file-preview" id="filePreview">
                        <img id="filePreviewImage" style="max-width: 100px; max-height: 100px; border-radius: 4px; display: none;">
                        <span id="filePreviewText"></span>
                    </div>
                    <button class="remove-file-btn" onclick="removeFile()">✕</button>
                </div>

                <!-- Input Container -->
                <div class="input-container">
                    <div class="input-actions">
                        <button class="action-btn" onclick="toggleFileUpload()" title="Upload Image">
                            📷
                        </button>
                        <button class="action-btn" onclick="toggleVoiceInput()" title="Voice Input" id="voiceBtn">
                            🎤
                        </button>
                        <button class="action-btn" onclick="openDrawingPad()" title="Draw">
                            ✏️
                        </button>
                    </div>

                    <div class="input-wrapper">
                        <textarea 
                            id="messageInput" 
                            placeholder="Type your message here..." 
                            rows="1"
                            onkeydown="handleKeyPress(event)"
                            oninput="autoResize(this)"
                        ></textarea>
                        <button class="send-btn" onclick="sendMessage()" id="sendBtn">
                            <span class="send-icon">➤</span>
                        </button>
                    </div>
                </div>

                <!-- Voice Input Indicator -->
                <div class="voice-indicator" id="voiceIndicator" style="display: none;">
                    <div class="voice-wave"></div>
                    <span>Listening...</span>
                    <button onclick="stopVoiceInput()">Stop</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Modal - Updated with simplified controls -->
    <div class="drawing-modal" id="drawingModal">
        <div class="drawing-container">
            <div class="drawing-header">
                <h3>Draw Your Question</h3>
                <button class="close-drawing" onclick="closeDrawingPad()">✕</button>
            </div>
            <canvas id="drawingCanvas" width="800" height="600" style="max-width: 100%; height: auto; display: block;"></canvas>
            <div class="drawing-controls">
                <button onclick="clearCanvas()">Clear Canvas</button>
                <button id="drawMode" onclick="setDrawMode('draw')" class="active">✏️ Draw</button>
                <button id="eraseMode" onclick="setDrawMode('erase')">🧹 Erase</button>
                <label for="brushSize">Brush Size:</label>
                <input type="range" id="brushSize" min="1" max="20" value="3" onchange="changeBrushSize(this.value)">
                <span id="brushSizeDisplay">3px</span>
                <button class="submit-drawing" onclick="submitDrawing()">Submit Drawing</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal-overlay" id="deleteModal" style="display: none;">
        <div class="modal-content">
            <h3>Delete Chat</h3>
            <p>Are you sure you want to delete this chat? This action cannot be undone.</p>
            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="closeDeleteModal()">Cancel</button>
                <button class="modal-btn confirm" onclick="confirmDeleteChat()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Clock Modal -->
    <div class="modal-overlay" id="clockModal" style="display: none;">
        <div class="modal-content" style="max-width: 320px;">
            <h3>Current Time</h3>
            <p id="clockDisplay" style="font-size: 1.6rem; font-weight: 700; letter-spacing: 1px; margin: 10px 0;">--:--:--</p>
            <div class="modal-actions">
                <button class="modal-btn confirm" onclick="closeClock()">Close</button>
            </div>
        </div>
    </div>

    <!-- Calculator Modal -->
    <div class="modal-overlay" id="calculatorModal" style="display: none;">
        <div class="modal-content" style="max-width: 420px;">
            <h3>Scientific Calculator</h3>
            <input id="calcInput" placeholder="e.g., sin(pi/2) + sqrt(2)" style="width: 100%; padding: 10px; margin: 12px 0; border: 2px solid #888; border-radius: 8px; background:#e8e8e8;" />
            <div id="calcResult" style="min-height: 24px; color:#333; margin-bottom:12px;"></div>
            <div class="modal-actions">
                <button class="modal-btn confirm" onclick="evaluateCalculator()">Calculate</button>
                <button class="modal-btn cancel" onclick="closeCalculator()">Close</button>
            </div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" style="display: none;" accept="image/*,.jpg,.jpeg,.png,.gif,.bmp,.webp" onchange="handleFileSelect(event)">

    <script>
        // Global variables
        let currentFile = null;
        let currentFilePreviewUrl = null;
        let isRecording = false;
        let recognition = null;
        let canvas = null;
        let ctx = null;
        let currentDrawMode = 'draw'; // 'draw' or 'erase'
        let brushSize = 3;
        let currentChatId = null;
        let currentUser = null;
        let chats = [];
        let chatToDelete = null;
        let chatToRename = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Initialize on DOM load
        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        async function init() {
            console.log('🚀 Initializing BYTE Chat...');
            await checkAuthentication();
            setupEventListeners();
            setupCanvas();
            setupSpeechRecognition();
            await loadChatHistory();
            
            // Start with sidebar closed by default
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                sidebar.classList.add('collapsed');
                const toggleBtn = document.getElementById('sidebarToggle');
                if (toggleBtn) {
                    toggleBtn.textContent = '☰';
                }
            }
            
            // Always start with a clean welcome screen
            showWelcomeScreen();
            console.log('✅ BYTE Chat initialized successfully');
        }

        // Authentication check
        async function checkAuthentication() {
            try {
                console.log('🔍 Checking authentication...');
                const response = await fetch('/api/auth/me', { credentials: 'include' });
                if (response.ok) {
                    const data = await response.json();
                    currentUser = data.user;
                    updateUserInterface();
                    console.log('✅ User authenticated:', currentUser.name);
                } else {
                    console.log('❌ User not authenticated, redirecting...');
                    window.location.href = 'auth.html';
                }
            } catch (error) {
                console.error('❌ Auth check failed:', error);
                showNotification('Authentication failed. Please login again.', 'error');
                setTimeout(() => {
                    window.location.href = 'auth.html';
                }, 2000);
            }
        }

        function updateUserInterface() {
            if (currentUser) {
                const userInitial = document.getElementById('userInitial');
                const userName = document.getElementById('userName');
                const userEmail = document.getElementById('userEmail');
                
                if (userInitial) {
                    userInitial.textContent = currentUser.name.charAt(0).toUpperCase();
                }
                
                if (userName) {
                    userName.textContent = currentUser.name;
                }
                
                if (userEmail) {
                    userEmail.textContent = currentUser.email;
                }
            }
        }

        async function logout() {
            try {
                console.log('🚪 Logging out...');
                const response = await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
                
                if (response.ok) {
                    console.log('✅ Logout successful');
                }
                
                // Clear local state
                currentChatId = null;
                currentUser = null;
                chats = [];
                cleanupFilePreview();
                
                showNotification('Logged out successfully!', 'success');
                
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 1000);
                
            } catch (error) {
                console.error('❌ Logout failed:', error);
                // Redirect anyway
                window.location.href = 'index.html';
            }
        }

        // Chat Management Functions
        async function loadChatHistory() {
            try {
                console.log('📚 Loading chat history...');
                const response = await fetch('/api/chats', { credentials: 'include' });
                if (response.ok) {
                    const data = await response.json();
                    chats = data.chats;
                    updateChatList();
                    console.log(`✅ Loaded ${chats.length} chats`);
                } else {
                    console.error('❌ Failed to load chat history:', response.status);
                    showNotification('Failed to load chat history', 'error');
                }
            } catch (error) {
                console.error('❌ Error loading chat history:', error);
                showNotification('Error loading chat history', 'error');
            }
        }

        function updateChatList() {
            const chatList = document.getElementById('chatList');
            if (!chatList) return;

            chatList.innerHTML = '';

            if (chats.length === 0) {
                chatList.innerHTML = '<div class="no-chats">No chats yet. Start a new conversation!</div>';
                return;
            }

            chats.forEach(chat => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${currentChatId === chat.id ? 'active' : ''}`;
                chatItem.onclick = () => loadChat(chat.id);
                
                chatItem.innerHTML = `
                    <div class="chat-item-content">
                        <div class="chat-title" title="${chat.title || `Chat ${chat.id}`}">${truncateText(chat.title || `Chat ${chat.id}`, 25)}</div>
                        <div class="chat-preview">${truncateText(chat.preview || 'No messages yet', 40)}</div>
                        <div class="chat-date">${formatDate(chat.updated_at)}</div>
                    </div>
                    <div class="chat-item-actions">
                        <button class="chat-action-btn" onclick="event.stopPropagation(); startRenameChat(${chat.id}, '${escapeString(chat.title || `Chat ${chat.id}`)}')" title="Rename Chat">
                            ✏️
                        </button>
                        <button class="chat-action-btn" onclick="event.stopPropagation(); deleteChat(${chat.id})" title="Delete Chat">
                            🗑️
                        </button>
                    </div>
                `;
                
                chatList.appendChild(chatItem);
            });
        }

        async function createNewChat() {
            try {
                console.log('➕ Creating new chat...');
                
                // Clear current chat state
                currentChatId = null;
                cleanupFilePreview();
                
                // Show welcome screen
                showWelcomeScreen();
                
                // Update chat list to remove active state
                updateChatList();
                
                showNotification('New chat started!', 'success');
                console.log('✅ New chat created');
            } catch (error) {
                console.error('❌ Failed to create new chat:', error);
                showNotification('Failed to create new chat', 'error');
            }
        }

        async function loadChat(chatId) {
            try {
                console.log(`📖 Loading chat ${chatId}...`);
                
                const response = await fetch(`/api/chats/${chatId}`, { credentials: 'include' });
                if (response.ok) {
                    const data = await response.json();
                    currentChatId = chatId;
                    displayChatMessages(data.messages);
                    updateChatList();
                    console.log(`✅ Loaded chat ${chatId} with ${data.messages.length} messages`);
                } else {
                    console.error('❌ Failed to load chat:', response.status);
                    showNotification('Failed to load chat', 'error');
                }
            } catch (error) {
                console.error('❌ Error loading chat:', error);
                showNotification('Failed to load chat', 'error');
            }
        }

        function displayChatMessages(messages) {
            const chatMessages = document.getElementById('chatMessages');
            const welcomeSection = document.getElementById('welcomeSection');
            
            if (messages.length > 0) {
                hideWelcomeSection();
                
                if (chatMessages) {
                    chatMessages.innerHTML = '';
                    
                    messages.forEach(message => {
                        if (message.message_type === 'image') {
                            addImageMessageToUI(message.sender, message.content);
                        } else {
                            addMessageToUI(message.sender, message.content);
                        }
                    });
                    
                    scrollToBottom();
                }
            } else {
                showWelcomeScreen();
            }
        }

        function showWelcomeScreen() {
            const welcomeSection = document.getElementById('welcomeSection');
            const chatMessages = document.getElementById('chatMessages');
            
            if (welcomeSection) {
                welcomeSection.style.display = 'flex';
            }
            if (chatMessages) {
                chatMessages.innerHTML = '';
                chatMessages.style.display = 'none';
            }
        }

        async function clearCurrentChat() {
            if (!currentChatId) {
                showWelcomeScreen();
                showNotification('Chat cleared!', 'success');
                return;
            }

            try {
                console.log(`🧹 Clearing chat ${currentChatId}...`);
                
                const response = await fetch(`/api/chats/${currentChatId}/clear`, {
                    method: 'POST',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    showWelcomeScreen();
                    await loadChatHistory();
                    showNotification('Chat cleared!', 'success');
                    console.log('✅ Chat cleared successfully');
                } else {
                    console.error('❌ Failed to clear chat:', response.status);
                    showNotification('Failed to clear chat', 'error');
                }
            } catch (error) {
                console.error('❌ Error clearing chat:', error);
                showNotification('Failed to clear chat', 'error');
            }
        }

        function deleteChat(chatId) {
            chatToDelete = chatId;
            const modal = document.getElementById('deleteModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        function closeDeleteModal() {
            chatToDelete = null;
            const modal = document.getElementById('deleteModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function confirmDeleteChat() {
            if (!chatToDelete) return;

            try {
                console.log(`🗑️ Deleting chat ${chatToDelete}...`);
                
                const response = await fetch(`/api/chats/${chatToDelete}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    // If we deleted the current chat, show welcome screen
                    if (chatToDelete === currentChatId) {
                        currentChatId = null;
                        showWelcomeScreen();
                    }
                    
                    await loadChatHistory();
                    showNotification('Chat deleted successfully!', 'success');
                    console.log('✅ Chat deleted successfully');
                } else {
                    console.error('❌ Failed to delete chat:', response.status);
                    showNotification('Failed to delete chat', 'error');
                }
            } catch (error) {
                console.error('❌ Error deleting chat:', error);
                showNotification('Failed to delete chat', 'error');
            }
            
            closeDeleteModal();
        }

        // Chat Renaming Functions
        function startRenameChat(chatId, currentTitle) {
            chatToRename = chatId;
            
            // Create inline input
            const chatItems = document.querySelectorAll('.chat-item');
            chatItems.forEach(item => {
                const titleElement = item.querySelector('.chat-title');
                if (titleElement && titleElement.textContent.includes(currentTitle.substring(0, 20))) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = currentTitle;
                    input.className = 'chat-rename-input';
                    input.style.cssText = `
                        width: 100%;
                        background: #e8e8e8;
                        border: 1px solid #999;
                        border-radius: 4px;
                        padding: 4px 8px;
                        font-size: 0.9rem;
                        font-weight: 600;
                        color: #333;
                    `;
                    
                    input.onblur = () => finishRenameChat(chatId, input.value);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            finishRenameChat(chatId, input.value);
                        } else if (e.key === 'Escape') {
                            cancelRenameChat();
                        }
                    };
                    
                    titleElement.innerHTML = '';
                    titleElement.appendChild(input);
                    input.focus();
                    input.select();
                }
            });
        }

        async function finishRenameChat(chatId, newTitle) {
            if (!newTitle.trim()) {
                cancelRenameChat();
                return;
            }

            try {
                const response = await fetch(`/api/chats/${chatId}/rename`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ title: newTitle.trim() })
                });
                
                if (response.ok) {
                    await loadChatHistory();
                    showNotification('Chat renamed successfully!', 'success');
                } else {
                    const errorData = await response.json();
                    showNotification(errorData.error || 'Failed to rename chat', 'error');
                    await loadChatHistory();
                }
            } catch (error) {
                console.error('❌ Error renaming chat:', error);
                showNotification('Failed to rename chat', 'error');
                await loadChatHistory();
            }
            
            chatToRename = null;
        }

        function cancelRenameChat() {
            chatToRename = null;
            loadChatHistory();
        }

        function escapeString(str) {
            return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        // MESSAGE HANDLING WITH IMAGE SUPPORT
        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput?.value.trim();

            if (!message && !currentFile) {
                console.log('⚠️ No message or file to send');
                return;
            }

            console.log('📤 Sending message...');
            hideWelcomeSection();

            const formData = new FormData();
            
            if (currentFile) {
                console.log('📷 Processing image file...');
                
                formData.append('image', currentFile);
                
                if (currentChatId) {
                    formData.append('chat_id', currentChatId);
                }
                
                if (message) {
                    formData.append('query', message);
                    addMessageToUI('user', message);
                }
                
                // Display the uploaded image in chat
                const imageUrl = currentFilePreviewUrl;
                addImageMessageToUI('user', imageUrl);
                
                if (messageInput) {
                    messageInput.value = '';
                    autoResize(messageInput);
                }
                removeFile();
                showTypingIndicator();
                
                try {
                    const response = await fetch('/api/recognize_handwriting', {
                        method: 'POST',
                        credentials: 'include',
                        body: formData
                    });
                    
                    hideTypingIndicator();
                    
                    if (response.ok) {
                        const data = await response.json();
                        currentChatId = data.chat_id;
                        addMessageToUI('bot', data.response);
                        await loadChatHistory();
                        console.log('✅ Image processed successfully');
                    } else {
                        const errorData = await response.json();
                        console.error('❌ Image processing failed:', errorData);
                        addMessageToUI('bot', 'Sorry, I had trouble processing your image. Please try again with a clearer image.');
                    }
                } catch (error) {
                    hideTypingIndicator();
                    console.error('❌ Image processing error:', error);
                    addMessageToUI('bot', 'Sorry, I had trouble processing your image. Please check your connection and try again.');
                }
            } else {
                console.log('💬 Processing text message...');
                
                formData.append('query', message);
                
                if (currentChatId) {
                    formData.append('chat_id', currentChatId);
                }
                
                addMessageToUI('user', message);
                
                if (messageInput) {
                    messageInput.value = '';
                    autoResize(messageInput);
                }
                
                showTypingIndicator();
                
                try {
                    const response = await fetch('/api/ask', {
                        method: 'POST',
                        credentials: 'include',
                        body: formData
                    });
                    
                    hideTypingIndicator();
                    
                    if (response.ok) {
                        const data = await response.json();
                        currentChatId = data.chat_id;
                        addMessageToUI('bot', data.response);
                        await loadChatHistory();
                        console.log('✅ Message processed successfully');
                    } else {
                        const errorData = await response.json();
                        console.error('❌ Message processing failed:', errorData);
                        addMessageToUI('bot', 'Sorry, I had trouble processing your message. Please try again.');
                    }
                } catch (error) {
                    hideTypingIndicator();
                    console.error('❌ Message processing error:', error);
                    addMessageToUI('bot', 'Sorry, I had trouble processing your message. Please check your connection and try again.');
                }
            }
        }

        // Sidebar Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebarToggle');
            
            if (sidebar) {
                sidebar.classList.toggle('collapsed');
                if (toggleBtn) {
                    toggleBtn.textContent = sidebar.classList.contains('collapsed') ? '☰' : '✕';
                }
            }
        }

        // Utility Functions
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substr(0, maxLength - 3) + '...';
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = now - date;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return 'Today';
            } else if (diffDays === 1) {
                return 'Yesterday';
            } else if (diffDays < 7) {
                return `${diffDays} days ago`;
            } else {
                return date.toLocaleDateString();
            }
        }

        // Event Listeners Setup
        function setupEventListeners() {
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('keydown', handleKeyPress);
                messageInput.addEventListener('input', () => autoResize(messageInput));
            }

            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
            }

            // Close modals on outside click
            document.addEventListener('click', function(e) {
                const drawingModal = document.getElementById('drawingModal');
                const deleteModal = document.getElementById('deleteModal');
                
                if (drawingModal && e.target === drawingModal) {
                    closeDrawingPad();
                }
                
                if (deleteModal && e.target === deleteModal) {
                    closeDeleteModal();
                }
            });

            // Global keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Escape to close modals
                if (e.key === 'Escape') {
                    const drawingModal = document.getElementById('drawingModal');
                    const deleteModal = document.getElementById('deleteModal');
                    
                    if (drawingModal && drawingModal.classList.contains('active')) {
                        closeDrawingPad();
                    } else if (deleteModal && deleteModal.style.display === 'flex') {
                        closeDeleteModal();
                    } else if (chatToRename) {
                        cancelRenameChat();
                    }
                }
                
                // Ctrl+N for new chat
                if (e.ctrlKey && e.key === 'n') {
                    e.preventDefault();
                    createNewChat();
                }
                
                // Ctrl+/ to toggle sidebar
                if (e.ctrlKey && e.key === '/') {
                    e.preventDefault();
                    toggleSidebar();
                }
            });
        }

        // Handle key press in message input
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // Auto-resize textarea
        function autoResize(textarea) {
            if (textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }
        }

        // MESSAGE DISPLAY FUNCTIONS
        function addMessageToUI(sender, content) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;

            chatMessages.style.display = 'flex';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-avatar">${sender === 'user' ? '👤' : '🤖'}</div>
                <div class="message-content">
                    ${content}
                    <div class="message-time">${timestamp}</div>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addImageMessageToUI(sender, imageUrl) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;

            chatMessages.style.display = 'flex';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-avatar">${sender === 'user' ? '👤' : '🤖'}</div>
                <div class="message-content image-message">
                    <img src="${imageUrl}" alt="Uploaded image" class="chat-image" onclick="openImageModal('${imageUrl}')">
                    <div class="message-time">${timestamp}</div>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function openImageModal(imageUrl) {
            const modal = document.createElement('div');
            modal.className = 'image-modal-overlay';
            modal.onclick = () => closeImageModal(modal);
            
            modal.innerHTML = `
                <div class="image-modal-content" onclick="event.stopPropagation()">
                    <button class="image-modal-close" onclick="closeImageModal(this.closest('.image-modal-overlay'))">✕</button>
                    <img src="${imageUrl}" alt="Full size image" class="image-modal-img">
                </div>
            `;
            
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            document.body.appendChild(modal);
        }

        function closeImageModal(modal) {
            if (modal && document.body.contains(modal)) {
                document.body.removeChild(modal);
            }
        }

        function hideWelcomeSection() {
            const welcomeSection = document.getElementById('welcomeSection');
            const chatMessages = document.getElementById('chatMessages');
            
            if (welcomeSection) {
                welcomeSection.style.display = 'none';
            }
            if (chatMessages) {
                chatMessages.style.display = 'flex';
            }
        }

        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        function showTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.style.display = 'flex';
                scrollToBottom();
            }
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        }

        function showNotification(message, type = 'info') {
            console.log(`${type.toUpperCase()}: ${message}`);
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                border-radius: 8px;
                z-index: 10000;
                font-weight: 500;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                animation: slideInRight 0.3s ease;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease forwards';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }

        // FILE HANDLING FUNCTIONS
        function toggleFileUpload() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.click();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                // Validate file type
                const validImageTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/webp'];
                
                if (!validImageTypes.includes(file.type)) {
                    showNotification('Please select a valid image file (JPEG, PNG, GIF, BMP, WebP)', 'error');
                    event.target.value = '';
                    return;
                }
                
                // Check file size (16MB limit)
                const maxSize = 16 * 1024 * 1024; // 16MB
                if (file.size > maxSize) {
                    showNotification('File is too large. Maximum size is 16MB.', 'error');
                    event.target.value = '';
                    return;
                }
                
                console.log('📷 Image selected:', file.name, file.type, formatFileSize(file.size));
                currentFile = file;
                
                // Create preview URL
                cleanupFilePreview();
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    currentFilePreviewUrl = e.target.result;
                    showFilePreview(file, currentFilePreviewUrl);
                };
                reader.readAsDataURL(file);
            }
        }

        function cleanupFilePreview() {
            if (currentFilePreviewUrl && currentFilePreviewUrl.startsWith('blob:')) {
                URL.revokeObjectURL(currentFilePreviewUrl);
            }
            currentFilePreviewUrl = null;
        }

        function showFilePreview(file, previewUrl) {
            const fileUploadArea = document.getElementById('fileUploadArea');
            const filePreviewText = document.getElementById('filePreviewText');
            const filePreviewImage = document.getElementById('filePreviewImage');
            
            if (fileUploadArea && filePreviewText && filePreviewImage) {
                fileUploadArea.style.display = 'flex';
                filePreviewText.textContent = `📷 ${file.name} (${formatFileSize(file.size)})`;
                filePreviewImage.src = previewUrl;
                filePreviewImage.style.display = 'block';
            }
        }

        function removeFile() {
            console.log('🗑️ Removing file');
            cleanupFilePreview();
            currentFile = null;
            
            const fileUploadArea = document.getElementById('fileUploadArea');
            const filePreviewText = document.getElementById('filePreviewText');
            const filePreviewImage = document.getElementById('filePreviewImage');
            const fileInput = document.getElementById('fileInput');
            
            if (fileUploadArea) {
                fileUploadArea.style.display = 'none';
            }
            if (filePreviewText) {
                filePreviewText.textContent = '';
            }
            if (filePreviewImage) {
                filePreviewImage.src = '';
                filePreviewImage.style.display = 'none';
            }
            if (fileInput) {
                fileInput.value = '';
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Voice input functions
        function toggleVoiceInput() {
            if (isRecording) {
                stopVoiceInput();
            } else {
                // Use MediaRecorder-based recording for explicit start/stop control
                startMediaRecorderFallback();
            }
        }

        function startVoiceInput() {
            // Route to media recorder for consistent UX
            startMediaRecorderFallback();
        }

        function stopVoiceInput() {
            console.log('🛑 Stopping voice input...');
            isRecording = false;
            const voiceBtn = document.getElementById('voiceBtn');
            const voiceIndicator = document.getElementById('voiceIndicator');
            
            if (voiceBtn) {
                voiceBtn.classList.remove('active');
                voiceBtn.innerHTML = '🎤';
            }
            
            if (voiceIndicator) {
                voiceIndicator.style.display = 'none';
            }
            
            // Stop browser recognition if active
            if (recognition) {
                try { recognition.stop(); } catch (e) {}
            }
            // Stop media recorder if active
            try { if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop(); } catch (e) {}
        }

        // Speech Recognition Setup
        function setupSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                // More stable: single-shot recognition to avoid mid-session errors
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                recognition.onresult = (event) => {
                    let interim = '';
                    let finalText = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const res = event.results[i];
                        if (res.isFinal) {
                            finalText += res[0].transcript;
                        } else {
                            interim += res[0].transcript;
                        }
                    }
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) {
                        messageInput.value = (finalText || interim).trim();
                        autoResize(messageInput);
                    }
                    // Do not auto-send; stop recording on final result only
                    if (finalText.trim()) {
                        stopVoiceInput();
                    }
                };

                recognition.onerror = (e) => {
                    console.warn('Speech error:', e.error);
                    // Gracefully ignore benign errors
                    const benign = ['no-speech', 'aborted', 'audio-capture'];
                    stopVoiceInput();
                    if (!benign.includes(e.error)) {
                        showNotification('Voice recognition error. Please try again.', 'error');
                    }
                };

                recognition.onend = () => {
                    // Reflect UI state and do not auto-restart to avoid loops
                    if (isRecording) {
                        stopVoiceInput();
                    }
                };

                console.log('🎤 Speech recognition initialized');
            } else {
                console.log('⚠️ Speech recognition not supported');
            }
        }

        // MediaRecorder fallback for browsers without SpeechRecognition
        let mediaRecorder = null;
        let recordedChunks = [];
        async function startMediaRecorderFallback() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        noiseSuppression: true,
                        echoCancellation: true,
                        autoGainControl: true,
                        channelCount: 1,
                        sampleRate: 48000
                    }
                });
                recordedChunks = [];
                const preferredType = MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus'
                    : 'audio/webm';
                mediaRecorder = new MediaRecorder(stream, { mimeType: preferredType, audioBitsPerSecond: 128000 });

                const voiceBtn = document.getElementById('voiceBtn');
                const voiceIndicator = document.getElementById('voiceIndicator');
                if (voiceBtn) {
                    voiceBtn.classList.add('active');
                    voiceBtn.innerHTML = '🔴';
                }
                if (voiceIndicator) voiceIndicator.style.display = 'flex';

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) recordedChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                    await uploadAudioForTranscription(blob);
                    stopVoiceUI();
                    stream.getTracks().forEach(t => t.stop());
                };

                mediaRecorder.start();
                // No auto stop; user controls duration via Stop
            } catch (e) {
                console.error('Microphone error:', e);
                showNotification('Microphone access denied or unavailable', 'error');
                stopVoiceUI();
            }
        }

        function stopVoiceUI() {
            isRecording = false;
            const voiceBtn = document.getElementById('voiceBtn');
            const voiceIndicator = document.getElementById('voiceIndicator');
            if (voiceBtn) {
                voiceBtn.classList.remove('active');
                voiceBtn.innerHTML = '🎤';
            }
            if (voiceIndicator) voiceIndicator.style.display = 'none';
        }

        async function uploadAudioForTranscription(blob) {
            try {
                const formData = new FormData();
                formData.append('audio', blob, 'voice.webm');
                const res = await fetch('/api/voice_to_text', { method: 'POST', body: formData, credentials: 'include' });
                if (!res.ok) {
                    showNotification('Audio upload failed', 'error');
                    return;
                }
                const data = await res.json();
                const transcript = (data.transcript || '').trim();
                if (transcript && transcript.length >= 3) {
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) {
                        messageInput.value = transcript;
                        autoResize(messageInput);
                    }
                    // Do not auto-send; let user edit and press send
                } else {
                    showNotification('Could not transcribe clearly. Please try speaking closer to the mic.', 'error');
                }
            } catch (err) {
                console.error('Upload transcription error:', err);
                showNotification('Transcription error. Please try again.', 'error');
            }
        }

        // FIXED CANVAS SETUP FOR DRAWING
        function setupCanvas() {
            canvas = document.getElementById('drawingCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
                
                // Set canvas size
                canvas.width = 800;
                canvas.height = 600;
                
                // Set initial drawing properties
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = brushSize;
                
                // Fill canvas with white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Add event listeners
                addCanvasEventListeners();
                
                console.log('🎨 Canvas initialized successfully');
            }
        }

        function addCanvasEventListeners() {
            if (!canvas) return;

            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', stopDrawing);
        }

        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches && e.touches[0]) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            } else {
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCanvasCoordinates(e);
            lastX = coords.x;
            lastY = coords.y;
            // Show eraser preview only while clicking in erase mode
            if (currentDrawMode === 'erase') {
                drawEraserCursor(coords.x, coords.y);
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const coords = getCanvasCoordinates(e);
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(coords.x, coords.y);
            
            if (currentDrawMode === 'erase') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = brushSize * 2; // Larger eraser
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = brushSize;
            }
            
            ctx.stroke();
            
            lastX = coords.x;
            lastY = coords.y;

            // Draw eraser preview circle when erasing
            if (currentDrawMode === 'erase') {
                drawEraserCursor(coords.x, coords.y);
            }
        }

        function stopDrawing(e) {
            if (isDrawing) {
                e.preventDefault();
                isDrawing = false;
                ctx.globalCompositeOperation = 'source-over'; // Reset to normal mode
                removeEraserPreview();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            startDrawing(e);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            draw(e);
        }

        // UPDATED DRAWING FUNCTIONS
        function openDrawingPad() {
            const modal = document.getElementById('drawingModal');
            if (modal) {
                modal.classList.add('active');
                clearCanvas();
                
                // Reset drawing settings
                currentDrawMode = 'draw';
                brushSize = 3;
                updateDrawingControls();
                
                // Ensure canvas is properly initialized
                if (canvas && ctx) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // Resize canvas to fit modal without scrolling
                resizeCanvasToFitModal();
                window.addEventListener('resize', resizeCanvasToFitModal);
            }
        }

        function closeDrawingPad() {
            const modal = document.getElementById('drawingModal');
            if (modal) {
                modal.classList.remove('active');
            }
            // Remove eraser preview if present
            const preview = document.getElementById('eraserPreview');
            if (preview && preview.parentNode) preview.parentNode.removeChild(preview);
            window.removeEventListener('resize', resizeCanvasToFitModal);
        }

        function clearCanvas() {
            if (ctx && canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Fill with white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        function resizeCanvasToFitModal() {
            const container = document.querySelector('.drawing-container');
            const header = document.querySelector('.drawing-header');
            const controls = document.querySelector('.drawing-controls');
            if (!container || !canvas) return;

            const containerStyles = getComputedStyle(container);
            const paddingY = parseInt(containerStyles.paddingTop) + parseInt(containerStyles.paddingBottom);
            const headerH = header ? header.offsetHeight : 0;
            const controlsH = controls ? controls.offsetHeight : 0;
            const gap = 8; // spacing between elements
            const canvasStyles = getComputedStyle(canvas);
            const canvasMarginBottom = parseInt(canvasStyles.marginBottom) || 0;

            const availableHeight = Math.max(200, container.clientHeight - paddingY - headerH - controlsH - gap - canvasMarginBottom);
            const availableWidth = container.clientWidth - (parseInt(containerStyles.paddingLeft) + parseInt(containerStyles.paddingRight));

            // Set CSS size
            canvas.style.width = availableWidth + 'px';
            canvas.style.height = availableHeight + 'px';

            // Match internal drawing buffer to displayed size for crisp lines
            const dpr = window.devicePixelRatio || 1;
            const newWidth = Math.floor(availableWidth * dpr);
            const newHeight = Math.floor(availableHeight * dpr);
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                ctx.scale(dpr, dpr);
                // Refill white background after resize
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, availableWidth, availableHeight);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = currentDrawMode === 'draw' ? 'black' : 'white';
                ctx.lineWidth = brushSize;
            }
        }

        function setDrawMode(mode) {
            currentDrawMode = mode;
            updateDrawingControls();
            if (currentDrawMode !== 'erase') {
                removeEraserPreview();
            }
        }

        function changeBrushSize(size) {
            brushSize = parseInt(size);
            const display = document.getElementById('brushSizeDisplay');
            if (display) {
                display.textContent = `${brushSize}px`;
            }
        }

        function updateDrawingControls() {
            // Update mode buttons
            const drawBtn = document.getElementById('drawMode');
            const eraseBtn = document.getElementById('eraseMode');
            
            if (drawBtn && eraseBtn) {
                drawBtn.classList.toggle('active', currentDrawMode === 'draw');
                eraseBtn.classList.toggle('active', currentDrawMode === 'erase');
            }
            
            // Update brush size display
            const brushSizeInput = document.getElementById('brushSize');
            const brushSizeDisplay = document.getElementById('brushSizeDisplay');
            if (brushSizeInput) {
                brushSizeInput.value = brushSize;
            }
            if (brushSizeDisplay) {
                brushSizeDisplay.textContent = `${brushSize}px`;
            }

            // Update canvas cursor style
            if (canvas) {
                if (currentDrawMode === 'erase') {
                    canvas.style.cursor = 'none'; // we draw our own
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
        }

        function drawEraserCursor(x, y) {
            if (!canvas || !ctx) return;
            // Save and draw overlay circle to indicate eraser size
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            // Redraw a subtle preview circle using an overlay technique
            // Create a temporary overlay using DOM element for clarity
            let preview = document.getElementById('eraserPreview');
            if (!preview) {
                preview = document.createElement('div');
                preview.id = 'eraserPreview';
                preview.style.position = 'absolute';
                preview.style.pointerEvents = 'none';
                preview.style.border = '1px solid rgba(17,24,39,0.5)';
                preview.style.borderRadius = '50%';
                preview.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.6) inset';
                const modal = document.getElementById('drawingModal');
                if (modal) modal.appendChild(preview);
            }
            const rect = canvas.getBoundingClientRect();
            const modal = document.getElementById('drawingModal');
            const modalRect = modal ? modal.getBoundingClientRect() : { left: 0, top: 0 };
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;
            const radius = (brushSize) * scaleX; // approximate scaling
            preview.style.width = `${radius * 2}px`;
            preview.style.height = `${radius * 2}px`;
            preview.style.left = `${(rect.left - modalRect.left) + x * scaleX - radius}px`;
            preview.style.top = `${(rect.top - modalRect.top) + y * scaleY - radius}px`;
            ctx.restore();
        }

        function removeEraserPreview() {
            const preview = document.getElementById('eraserPreview');
            if (preview && preview.parentNode) preview.parentNode.removeChild(preview);
        }

        async function submitDrawing() {
            if (!canvas) {
                showNotification('Drawing canvas not available', 'error');
                return;
            }
            
            // Check if canvas has any drawing (not just white background)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixelData = imageData.data;
            let hasNonWhitePixel = false;
            
            // Check every 4th pixel (RGBA) for non-white values
            for (let i = 0; i < pixelData.length; i += 4) {
                const r = pixelData[i];
                const g = pixelData[i + 1];
                const b = pixelData[i + 2];
                
                // If any pixel is not white (255, 255, 255)
                if (r !== 255 || g !== 255 || b !== 255) {
                    hasNonWhitePixel = true;
                    break;
                }
            }
            
            if (!hasNonWhitePixel) {
                showNotification('Please draw something before submitting', 'error');
                return;
            }
            
            console.log('🎨 Submitting drawing...');
            hideWelcomeSection();
            
            canvas.toBlob(async function(blob) {
                if (!blob) {
                    showNotification('Failed to process drawing', 'error');
                    return;
                }
                
                const formData = new FormData();
                formData.append('image', blob, 'drawing.png');
                
                if (currentChatId) {
                    formData.append('chat_id', currentChatId);
                }
                
                // Display the drawing in chat
                const drawingUrl = canvas.toDataURL();
                addImageMessageToUI('user', drawingUrl);
                
                closeDrawingPad();
                showTypingIndicator();
                
                try {
                    const response = await fetch('/api/recognize_handwriting', {
                        method: 'POST',
                        credentials: 'include',
                        body: formData
                    });
                    
                    hideTypingIndicator();
                    
                    if (response.ok) {
                        const data = await response.json();
                        currentChatId = data.chat_id;
                        addMessageToUI('bot', data.response);
                        await loadChatHistory();
                        console.log('✅ Drawing processed successfully');
                    } else {
                        const errorData = await response.json();
                        console.error('❌ Drawing processing failed:', errorData);
                        addMessageToUI('bot', 'Sorry, I had trouble processing your drawing. Please try again with clearer handwriting or drawings.');
                    }
                } catch (error) {
                    hideTypingIndicator();
                    console.error('❌ Drawing processing error:', error);
                    addMessageToUI('bot', 'Sorry, I had trouble processing your drawing. Please check your connection and try again.');
                }
            }, 'image/png', 0.8);
        }

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);

        console.log('📝 BYTE Chat Script loaded successfully');

        // Clock timer update
        setInterval(() => {
            const el = document.getElementById('clockDisplay');
            if (el && document.getElementById('clockModal')?.style.display === 'flex') {
                const now = new Date();
                el.textContent = now.toLocaleTimeString();
            }
        }, 500);
    </script>
    <script src="chatbot-script.js"></script>
</body>
</html>